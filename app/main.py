# app/main.py\n\nfrom fastapi import FastAPI, File, UploadFile, Form, HTTPException\nfrom fastapi.responses import FileResponse\nfrom pydantic import BaseModel\nimport os\nimport shutil\nimport numpy as np\nimport time\nimport json\n\nfrom app.utils.feature_extractor import get_ecapa_embedding_from_file\nfrom app.utils.storage import save_embedding, load_all_embeddings\nfrom app.utils.compare import match_embedding, THRESHOLD\n\napp = FastAPI()\n\n# --- DIRECTORIES ---\nTEMP_DIR = \"app/data/temp_audio\"\nAUDIO_STORAGE_DIR = \"app/data/alert_audio\"\nDATA_DIR = \"app/data\"\nLOCATION_FILE = os.path.join(DATA_DIR, \"latest_location.json\")\n\nos.makedirs(TEMP_DIR, exist_ok=True)\nos.makedirs(AUDIO_STORAGE_DIR, exist_ok=True)\nos.makedirs(DATA_DIR, exist_ok=True)\n\n\n# --- IN-MEMORY STORAGE (for demonstration) ---\n# In a real app, these should be managed in a persistent database.\n\n# Holds the current state for mutual exclusivity\napp_state = {\n    \"mode\": \"none\",  # Can be \"none\", \"child_active\", or \"parent_active\"\n    \"active_device_id\": None\n}\n\n# Stores alerts received from child devices\nalerts_storage = []\n\n\nclass LocationData(BaseModel):\n    latitude: float\n    longitude: float\n\n# ------------------ DEVICE MODE LOCKING ------------------\n\n@app.post(\"/start_child_mode\")\nasync def start_child_mode(device_id: str = Form(...)):\n    \'\'\'Acquires a lock for a device to enter \'Child Mode\'.\'\'\'\n    if app_state[\"mode\"] == \"child_active\" and app_state[\"active_device_id\"] != device_id:\n        raise HTTPException(status_code=423, detail=\"Child mode is already active on another device.\")\n    \n    app_state[\"mode\"] = \"child_active\"\n    app_state[\"active_device_id\"] = device_id\n    print(f\"‚úÖ Child mode started for device: {device_id}\")\n    return {\"status\": \"success\", \"mode\": \"child_active\", \"device_id\": device_id}\n\n@app.post(\"/start_parent_mode\")\nasync def start_parent_mode(device_id: str = Form(...)):\n    \'\'\'Acquires a lock for a device to enter \'Parent Mode\'.\'\'\'\n    if app_state[\"mode\"] == \"parent_active\" and app_state[\"active_device_id\"] != device_id:\n        raise HTTPException(status_code=423, detail=\"Parent mode is already active on another device.\")\n        \n    app_state[\"mode\"] = \"parent_active\"\n    app_state[\"active_device_id\"] = device_id\n    print(f\"‚úÖ Parent mode started for device: {device_id}\")\n    return {\"status\": \"success\", \"mode\": \"parent_active\", \"device_id\": device_id}\n\n@app.post(\"/release_mode\")\nasync def release_mode(device_id: str = Form(...)):\n    \'\'\'Releases the lock held by a device.\'\'\'\n    if app_state[\"active_device_id\"] == device_id:\n        print(f\"‚ÑπÔ∏è Releasing lock for device: {device_id}. Current mode: {app_state[\'mode\']}\")\n        app_state[\"mode\"] = \"none\"\n        app_state[\"active_device_id\"] = None\n        return {\"status\": \"success\", \"message\": \"Mode released.\"}\n    \n    print(f\"‚ö†Ô∏è Received release request from non-active device: {device_id}. Current active: {app_state[\'active_device_id\']}\")\n    return {\"status\": \"success\", \"message\": \"No active lock found for this device, but request was processed.\"}\n\n@app.get(\"/get_status\")\nasync def get_status():\n    \'\'\'Returns the current status of the device mode lock.\'\'\'\n    return app_state\n\n\n# ------------------ ALERT HANDLING ------------------\n\n@app.post(\"/alert\")\nasync def receive_alert(\n    latitude: str = Form(...),\n    longitude: str = Form(...),\n    file: UploadFile = File(...)\n):\n    \'\'\'Receives an alert from a child device, stores it, and prepares for parent pickup.\'\'\'\n    timestamp = int(time.time() * 1000)\n    audio_filename = f\"{timestamp}.wav\"\n    audio_path = os.path.join(AUDIO_STORAGE_DIR, audio_filename)\n\n    with open(audio_path, \"wb\") as buffer:\n        shutil.copyfileobj(file.file, buffer)\n\n    map_link = f\"http://maps.google.com/maps?q={latitude},{longitude}\"\n    audio_url = f\"/audio/{audio_filename}\"\n\n    new_alert = {\n        \"timestamp\": timestamp,\n        \"location\": map_link,\n        \"audio_url\": audio_url\n    }\n    \n    alerts_storage.append(new_alert)\n    print(f\"üö® New Alert Received: {new_alert}\")\n    \n    return {\"status\": \"success\", \"alert_received\": new_alert}\n\n@app.get(\"/get_alerts\")\nasync def get_alerts(since: int = 0):\n    \"\"\"\n    Endpoint for the parent app to poll for new alerts.\n    Filters alerts based on a \'since\' timestamp (in milliseconds).\n    The parent device is responsible for tracking the timestamp of the last alert it received.\n    \"\"\"\n    # Filter alerts that are newer than the provided timestamp\n    alerts_to_send = [alert for alert in alerts_storage if alert[\"timestamp\"] > since]\n    \n    if alerts_to_send:\n        print(f\"üì¶ Found {len(alerts_to_send)} new alerts for a request with \'since={since}\'.\")\n        \n    return alerts_to_send\n\n@app.get(\"/audio/{file_name}\")\nasync def get_audio_file(file_name: str):\n    \'\'\'Serves the stored audio file for an alert.\'\'\'\n    file_path = os.path.join(AUDIO_STORAGE_DIR, file_name)\n    if os.path.exists(file_path):\n        return FileResponse(file_path, media_type=\"audio/wav\")\n    raise HTTPException(status_code=404, detail=\"Audio file not found\")\n\n\n# ------------------ UPDATE LOCATION ------------------\n@app.post(\"/update_location\")\nasync def update_location(location: LocationData):\n    try:\n        with open(LOCATION_FILE, \"w\") as f:\n            json.dump(location.dict(), f)\n        print(f\"üìç Location updated and saved to file: {location.dict()}\")\n        return {\"status\": \"success\", \"received_location\": location.dict()}\n    except Exception as e:\n        print(f\"üî• ERROR: Failed to write location to file: {e}\")\n        raise HTTPException(status_code=500, detail=\"Could not save location data.\")\n\n# ------------------ TEST CONNECTION ------------------\n@app.get(\"/test_connection\")\ndef test_connection():\n    return {\"status\": \"ok\"}\n\n\n# ------------------ LIST SPEAKERS ------------------\n@app.get(\"/list_speakers\")\ndef list_speakers():\n    users = load_all_embeddings()\n    return {\"speakers\": list(users.keys())}\n\n#---------------------DELETE----------------------\n@app.delete(\"/delete_speaker/{name}\")\ndef delete_speaker(name: str):\n    speaker_dir = os.path.join(\"app\", \"data\", \"familiar_embeddings\", name)\n    if not os.path.exists(speaker_dir):\n        raise HTTPException(status_code=404, detail=\"Speaker not found\")\n    shutil.rmtree(speaker_dir)\n    return {\"status\": \"deleted\", \"speaker\": name}\n\n\n# ------------------ CLEAR TEMP AUDIO ------------------\n@app.post(\"/clear_temp_audio\")\ndef clear_temp_audio():\n    try:\n        shutil.rmtree(TEMP_DIR)\n        os.makedirs(TEMP_DIR, exist_ok=True)\n        return {\"status\": \"success\", \"message\": \"Temporary audio files cleared\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Failed to clear temporary audio files: {e}\")\n\n\n# ------------------ ENROLL ------------------\n@app.post(\"/enroll\")\nasync def enroll(\n    name: str = Form(...),\n    file: UploadFile = File(...)\n):\n    temp_path = os.path.join(TEMP_DIR, file.filename)\n    with open(temp_path, \"wb\") as buffer:\n        shutil.copyfileobj(file.file, buffer)\n    emb = get_ecapa_embedding_from_file(temp_path)\n    save_embedding(name, emb)\n    return {\n        \"status\": \"enrolled\",\n        \"name\": name,\n        \"embedding_dim\": len(emb)\n    }\n\n\n# ------------------ VERIFY (FAMILIARITY CHECK) ------------------\n@app.post(\"/verify\")\nasync def verify(file: UploadFile = File(...)):\n    temp_path = os.path.join(TEMP_DIR, file.filename)\n    with open(temp_path, \"wb\") as buffer:\n        shutil.copyfileobj(file.file, buffer)\n    query_emb = get_ecapa_embedding_from_file(temp_path)\n    users = load_all_embeddings()\n\n    # If there are no enrolled users, any voice is a stranger.\n    if not users:\n        print(\"ü§∑ No familiar voices enrolled. Automatically classifying as stranger.\")\n        best_score = 0.0 # Or some other indicator of no match\n    else:\n        best_match = None\n        best_score = 0.0\n        for user, stored_emb in users.items():\n            score = match_embedding(query_emb, stored_emb)\n            if score > best_score:\n                best_score = score\n                best_match = user\n        \n        if best_score >= THRESHOLD:\n            return {\n                \"result\": \"familiar\",\n                \"name\": best_match,\n                \"similarity\": float(best_score)\n            }\n\n    # Stranger detected. Create an alert.\n    print(\"üïµÔ∏è Stranger detected. Checking for location data...\")\n    latest_location = None\n    if os.path.exists(LOCATION_FILE):\n        try:\n            with open(LOCATION_FILE, \"r\") as f:\n                latest_location = json.load(f)\n            print(f\"‚úÖ Found location data: {latest_location}\")\n        except Exception as e:\n            print(f\"üî• ERROR: Failed to read or parse location file: {e}\")\n    else:\n        print(\"‚ö†Ô∏è Location file not found.\")\n\n    if latest_location:\n        timestamp = int(time.time() * 1000)\n        audio_filename = f\"{timestamp}.wav\"\n        audio_path = os.path.join(AUDIO_STORAGE_DIR, audio_filename)\n        \n        # Copy the received audio file to the alert audio storage\n        shutil.copyfile(temp_path, audio_path)\n        \n        map_link = f\"http://maps.google.com/maps?q={latest_location[\'latitude\']},{latest_location[\'longitude\']}\"\n        audio_url = f\"/audio/{audio_filename}\"\n\n        new_alert = {\n            \"timestamp\": timestamp,\n            \"location\": map_link,\n            \"audio_url\": audio_url\n        }\n        \n        alerts_storage.append(new_alert)\n        print(f\"üö® New Alert generated from /recognize (stranger): {new_alert}\")\n    else:\n        print(\"‚ö†Ô∏è Stranger detected via /recognize, but no location data available to create an alert.\")\n        \n    return {\n        \"result\": \"stranger\",\n        \"similarity\": float(best_score)\n    }\n\n\n# ------------------ ANDROID USES /recognize ------------------\n@app.post(\"/recognize\")\nasync def recognize(file: UploadFile = File(...)):\n    return await verify(file)\n\n\n# ------------------ ROOT ROUTE ------------------\n@app.get(\"/\")\def home():\n    return {\"message\": \"Speaker Recognition Backend Running\"}\n